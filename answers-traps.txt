### 问题一

Q: 哪些寄存器存储了函数调用的参数？举个例子，main 调用 printf 的时候，13 被存在了哪个寄存器中？
A: A1. a0-a7, a2.

根据第 45 行代码，可以看到 13 被放到了 a2 寄存器中。猜测是 a0-a7 寄存器保存参数。

### 问题二

Q: main 中调用函数 f 对应的汇编代码在哪？对 g 的调用呢？ (提示：编译器有可能会内联(inline)一些函数)
A: nowhere, compiler optimization by inline function.

其实是没有这样的代码。 g(x) 被内联到 f(x) 中，然后 f(x) 又被进一步内联到 main() 中。所以看到的不是函数跳转，而是优化后的内联函数。

### 问题三

Q: printf 函数所在的地址是？
A: 0x0000000000000630 (ra=pc=0x30, 1536(ra)=0x0000000000000630).

其实，直接在 user/call.asm 代码中一直找，就能找到 printf 函数的地址。

也可以通过计算得到，首先将当前程序计数器的值赋给 ra 寄存器。`auipc ra, 0x0`，是指将当前立即数向右移动12位，然后加上 pc 寄存器的值，赋给 ra 寄存器，由于立即数为 0，因此 ra 的值即为 pc 的值。当前指令在0x30处，因此 pc = 0x30。1536(ra) 是指 1536 加上 ra 寄存器的值，1536 转为16进制再加上0x30 即为 0x0000000000000630。刚好是 printf 的地址。

### 问题四

Q: 在 main 中 jalr 跳转到 printf 之后，ra 的值是什么？
A: 0x38(ra=pc+4).

jalr 指令会将 pc + 4 赋给当前寄存器，刚好是其下一条指令的地址。

### 问题五

Q: 运行下面的代码

	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);      

输出是什么？
如果 RISC-V 是大端序的，要实现同样的效果，需要将 i 设置为什么？需要将 57616 修改为别的值吗？

A: He110 World, 0x726c6400, no change for 57616.

％x 表示以十六进制数形式输出整数，57616 的16进制表示就是 e110，与大小端序无关。
%s 是输出字符串，以整数 i 所在的开始地址，按照字符的格式读取字符，直到读取到 '\0' 为止。当是小端序表示的时候，内存中存放的数是：72 6c 64 00，刚好对应rld。当是大端序的时候，则反过来了，因此需要将 i 以16进制数的方式逆转一下。

### 问题六

Q: 在下面的代码中，'y=' 之后会答应什么？ (note: 答案不是一个具体的值) 为什么?

	printf("x=%d y=%d", 3);

A: print the value of a2 register.

printf 接收到了两个参数，但实际需要三个参数，最后一个参数是放在 a2 寄存器中，由于没有输入第三个参数，因此 a2 寄存器中目前有啥就输出啥。

